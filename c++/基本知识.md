
# C++ 内存分区

- 栈（stack）：指那些由编译器在需要的时候分配，不需要时⾃动清除的变量所在的存储区，效率高，分配的内存空间有限，形参和局部变量分配在栈区，栈是向地地址生长的数据结构，是一块连续的内存

- 堆（heap）：由程序员控制内存的分配和释放的存储区，是向高地址生长的数据结构，是不连续的存储空间，堆的分配(malloc)和释放(free)有程序员控制，容易造成二次删除和内存泄漏

- 静态存储区（static）：存放全局变量和静态变量的存储区，初始化的变量放在初始化区，未初始化的变量放在未初始化区。在程序结束后释放这块空间

- 常量存储区（const）：存放常量字符串的存储区，只能读不能写，const修饰的局部变量存储在常量区（取决于编译器），const修饰的局部变量在栈区

- 程序代码区：存放源程序二进制代码

# C++ 多态
C++ 的多态体现在「重载」和「重写」。

## 编译时多态
一个函数存在不同的参数列表，即函数的「重载」。

## 运行时多态 -- 虚函数
虚函数是C++标准所制定的，实现虚函数时，各大编译器都采用「虚函数表」。

「虚函数表」是保存类内虚函数地址的表格，一个类，共享同一个虚函数表。
「虚函数表指针」是指向虚函表的指针，其由类的实例持有。

### 构造函数和析构函数可以是虚函数吗？

{% hint style="info" %}
参考内容：Effective C++, Item7 
{% endhint %}

构造函数不能是虚函数，因为在构造函数执行前，类的虚函数表指针是空的。
析构函数最好是虚函数，因为一个父类指针可能指向子类对象，在这种情况下，只有构造函数为虚函数，才能保证对子类进行析构，避免内存泄漏。

当存在一个函数为虚函数时，需要将析构函数生命为虚函数以防止潜在的内存泄露。
但不存在虚函数时，则不需要将析构函数生命为虚函数，可以节省虚函数指针与虚函数表的额外开销。


# 静态链接(库)和动态链接(库)

{% hint style="info" %}
参考内容：https://zhuanlan.zhihu.com/p/83716863
{% endhint %}

在一个程序的编译过程中，分为以下几个步骤：**预处理，编译，汇编，链接。**
其中链接的库分为两种「静态链接库:」和「动态链接库」，前者对应`.a`/`.lib`， 后者对应`.so`/`.dll`。

对于「静态链接库」而言在链接阶段，会将汇编生成的「目标文件.o」与引用到的库一起链接打包到可执行文件中。因此对应的链接方式称为静态链接。
- 静态链接库对函数库的链接是放在**编译时期**完成的。程序在运行时与函数库就没有了任何的联系。
- 它可能比较浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。
- 静态库对程序的更新和发布也会带来麻烦。如果静态库更新了，所有使用它的应用程序都需要重新编译、部署、发布给用户。

「动态链接库」在程序编译时并不会被连接到目标代码中，而是在程序运行时才被载入。
- 不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，可以实现进程之间的资源共享。（因此动态库也称为共享库）规避了空间浪费问题。
- 动态库在程序运行时才被载入，也解决了静态库对程序的更新、部署和发布带来的麻烦。用户只需要更新动态库即可将一些程序升级变得简单，增量更新。

# Static 关键字

- 修饰普通全局变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。
  
- 修饰普通变量，

- 修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。

- 修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。

- 修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。

# 类型转换

## static_cast

- 用于非多态类型的转换

- 不执行运行时类型检查（转换安全性不如 dynamic_cast）
  
- 通常用于转换数值数据类型（如 float -> int）
  
- 可以在整个类层次结构中移动指针，子类转化为父类安全（向上转换），父类转化为子类不安全（因为子类可能有不在父类的字段或方法）

## dynamic_cast

- 用于多态类型的转换
  
- 只适用于指针或引用
  
- 执行行运行时类型检查
  
- 对不明确的指针的转换将失败（返回 nullptr），但不引发异常
  
- 可以在整个类层次结构中移动指针，包括向上转换、向下转换

## const_cast

- 用于删除 const、volatile 和 __unaligned 特性（如将 const int 类型转换为 int 类型 ）

## reinterpret_cast

- 非常激进的指针类型转换，在编译期完成，可以转换任何类型的指针，所以极不安全。非极端情况不要使用。

# 引用

## 左值引用
常规引用，一般表示对象的身份。

## 右值引用
右值引用就是必须绑定到右值（一个临时对象、将要销毁的对象）的引用，一般表示对象的值。

右值引用可实现转移语义（Move Sementics）和精确传递（Perfect Forwarding），它的主要目的有两个方面：

消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。
能够更简洁明确地定义泛型函数。

# new 与 malloc 的区别

**最大的区别：**new在申请空间的时候会调用构造函数，malloc不会调用。在对象消失时会调用析构函数。

new会先调operator new函数，申请足够的内存（底层也是malloc实现），然后调用类的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数来释放内存（底层是通过free实现）。malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构函数

**申请失败返回：**new在申请空间失败后返回的是错误码bad_alloc，malloc在申请空间失败后会返回NULL。

**属性上：**new/delete是C++关键字需要编译器支持，maollc是库函数，需要添加头文件。

**参数：**new在申请内存分配时不需要指定内存块大小，编译器会更具类型计算出大小，malloc需要显示的指定所需内存的大小。

**成功返回类型：**new操作符申请内存成功时，返回的是对象类型的指针，类型严格与对象匹配，无需进行类型转换，因此new是类型安全性操作符。malloc申请内存成功则返回void*，需要强制类型转换为我们所需的类型。

# const

**修饰变量**，说明该变量不可以被改变；

**修饰指针**，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；

**修饰引用**，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改；

**修饰成员函数**，说明该成员函数内不能修改成员变量。

# volatile 

{% hint style="info" %}
参考内容：https://stackoverflow.com/questions/4437527/why-do-we-use-volatile-keyword
{% endhint %}

关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。

# 数组名与指针


指针和数组名的共同特点是都是用来指代一个地址的。

不同的是：
 1. 指针是需要占用内存空间来存储地址的；数组名则更像是一个立即数或者常数。你可以修改指针指向的内容，但你绝对无法改变数组名的指向。
> 对于变量名来说，在编译时，编译器会生成「符号表」来保存变量名到内存地址的映射，在编译后，变量名便被替换成地址，不在占用额外空间。但是如果启用了 `debug` 模式，变量名则会占用空间。
   
 2. 数组和指针对于 `sizeof` 来说是不同的，指针变量占用的空间通常等于当前CPU的最大位数，数组名取 `sizeof` 的话，得到的则是数组的大小。
   
 3. 对取地址 `&` 是不同的，对于指针取地址，得到的「指向指针的指针」。对于数组名取地址，得到的是「指向长度为n的数组的指针」：
 ```C++
    int a[5]   = {0};
    int(*p)[5] = &a;
 ```


